### 图像入门

[3_1_图像的基本操作 - OpenCV中文官方文档 (woshicver.com)](http://www.woshicver.com/FourthSection/3_1_图像的基本操作/)

#### 读取图像

使用**cv.imread**()函数读取图像。图像应该在工作目录或图像的完整路径应给出。

第二个参数是一个标志，它指定了读取图像的方式。包括以下三个标志：

- cv.IMREAD_COLOR： 加载彩色图像。任何图像的透明度都会被忽视。它是默认标志。
- cv.IMREAD_GRAYSCALE：以灰度模式加载图像
- cv.IMREAD_UNCHANGED：加载图像，包括alpha通道

> **注意** 除了这三个标志，你可以分别简单地传递整数1、0或-1。

#### 显示图像

使用函数**cv.imshow()**在窗口中显示图像。窗口自动适合图像尺寸。

第一个参数是窗口名称，它是一个字符串。第二个参数是我们的对象。你可以根据需要创建任意多个窗口，但可以使用不同的窗口名称。

**cv.waitKey**()是一个键盘绑定函数。其参数是以毫秒为单位的时间。该函数等待任何键盘事件指定的毫秒，即图像展示的时间。如果您在这段时间内按下任何键，程序将继续运行。如果**0**被传递，它将无限期地等待一次敲击键。

**cv.destroyAllWindows**()只会破坏我们创建的所有窗口。如果要销毁任何特定的窗口，请使用函数 **cv.destroyWindow**()在其中传递确切的窗口名称作为参数。

> **注意** 在特殊情况下，你可以创建一个空窗口，然后再将图像加载到该窗口。在这种情况下，你可以指定窗口是否可调整大小。这是通过功能**cv.namedWindow**()完成的。默认情况下，该标志为**cv.WINDOW_AUTOSIZE**。但是，如果将标志指定为**cv.WINDOW_NORMAL**，则可以调整窗口大小。当图像尺寸过大以及向窗口添加跟踪栏时，这将很有帮助。否则鼠标点击，图片就会消失。

#### 写入图像

使用函数**cv.imwrite**()保存图像。

第一个参数是文件名，第二个参数是要保存的图像。 `cv.imwrite('messigray.png'，img)`

这会将图像以PNG格式保存在工作目录中。

#### 使用Matplotlib

[Matplotlib 文档 — Matplotlib 3.8.0 文档](https://matplotlib.org/stable/)

OpenCV加载的彩色图像处于BGR模式。但是Matplotlib以RGB模式显示。因此，如果使用OpenCV读取彩色图像，则Matplotlib中将无法正确显示彩色图像。

### 图像的基本操作

数字图像由像素点组成，而每个像素点通常使用红、绿、蓝三个分量来表示颜色，即RGB模型。每个颜色通道的取值范围通常是0到255，其中0表示最暗的颜色（比如黑色），255表示最亮的颜色（比如白色）。

| 需要注意的是，一些图像格式可能还包含其他的颜色通道，如透明度通道（Alpha通道）用于控制像素的透明度。这些通道的组合形成了图像中每个像素点的完整表示。 |
| ------------------------------------------------------------ |

你可以通过行和列坐标来访问像素值。对于 BGR 图像，它返回一个由蓝色、绿色和红色值组成的数组。对于灰度图像，只返回相应的灰度。

```
>>> px = img[100,100]
>>> print( px )
[157 166 200]
# 仅访问蓝色像素
>>> blue = img[100,100,0]
>>> print( blue )
157
```

对于单个像素访问，Numpy数组方法array.item()和array.itemset())被认为更好，但是它们始终返回标量。如果要访问所有B，G，R值，则需要分别调用所有的array.item()。

```
# 访问 RED 值
>>> img.item(10,10,2)
59
# 修改 RED 值
>>> img.itemset((10,10,2),100)
>>> img.item(10,10,2)
100
```

#### 访问图像属性

图像的形状可通过`img.shape`访问。它返回行，列和通道数的元组（如果图像是彩色的）

> **注意** 如果图像是灰度的，则返回的元组仅包含行数和列数，因此这是检查加载的图像是灰度还是彩色的好方法。

像素总数可通过访问`img.size`.

图像数据类型通过`img.dtype`获得。

> **注意** img.dtype在调试时非常重要，因为OpenCV-Python代码中的大量错误是由无效的数据类型引起的。

#### 图像感兴趣区域ROI

使用Numpy索引再次获得ROI。在这里，我要选择球并将其复制到图像中的另一个区域：

```
>>> ball = img[280:340, 330:390]
>>> img[273:333, 100:160] = ball 
```

#### 拆分和合并图像通道

```
>>> b,g,r = cv.split(img) >>> img = cv.merge((b,g,r))

>>> b = img [:, :, 0]
```

**警告**

`cv.split()`是一项**耗时**的操作（就时间而言）。因此，仅在必要时才这样做。否则请进行Numpy索引。

#### 为图像设置边框（填充）

```
cv.copyMakeBorder()
##src - 输入图像
top，bottom，left，right 边界宽度（以相应方向上的像素数为单位）
borderType - 定义要添加哪种边框的标志。
value -边框的颜色
```

### 图像上的算术运算

#### 图像加法

您可以通过OpenCV函数`cv.add()`或仅通过numpy操作`res = img1 + img2`添加两个图像。两个图像应具有相同的深度和类型，或者第二个图像可以只是一个标量值。

> **注意** OpenCV加法和Numpy加法之间有区别。OpenCV加法是饱和运算，而Numpy加法是模运算。

```
>>> x = np.uint8([250])
>>> y = np.uint8([10])
>>> print( cv.add(x,y) ) # 250+10 = 260 => 255
[[255]]
>>> print( x+y )          # 250+10 = 260 % 256 = 4
[4]
```

#### 图像融合

但是对图像赋予不同的权重，以使其具有融合或透明的感觉
$$
G
(
x
)
=
(
1
−
α
)
f
0
(
x
)
+
α
f
1
(
x
)
$$

```
dst = cv.addWeighted(img1,0.7,img2,0.3,0)
```

### 按位运算

这包括按位 `AND`、 `OR`、`NOT` 和 `XOR` 操作。它们在提取图像的任何部分(我们将在后面的章节中看到)、定义和处理非矩形 ROI 等方面非常有用。）

调试
